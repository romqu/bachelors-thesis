\subsection{Solution}
\label{subsec:solution}


In order to reduce the cognitive burden on the developer when implementing the various components of MVI, the aim 
is to create a small, but opinionated library.
Hierfür müssen im ersten Schritt die Ereignisse die von einer Aktion des Nutzer ausgehen eindeutig identifiziert und beschrieben werden.
Über eine "intent"-Funktion die bereitgestellt wird, wird das Ereignisse in etwas übersetzt, dass die Intention im Kontext der Applikation
deutlich macht. So kann ein langer Klick auf ein Item innerhalb einer Liste bswp. als die Intention der Löschung interpertiert werden.
Im nächsten Schritt erfolgt die Ausführung dieser Intention in der "model"-Funktion. Dabei kann es unteranderem Vorkommen, dass der 
Entwickler auf die Geschäftslogik zugreifen muss und somit Seiteneffekte entstehen. Dazu wird seitens der Bibliothek mittels
reaktiver Programmierung Abhilfe geschaffen. Zusätzlich wird an diesem Punkt dem Entwickler das Model zur Verfügung gestellt.
Es handelt sich dabei um eine unveränderliche Datenstruktur



The core of the library will be centered around a mealy state machine leveraging pattern matching
and reducer functions to create a new state from a prior state and event.


Um den genannten Problem entgegenzuwirken gilt es, ein Muster zu entwerfen,
in welchem der "Zustand" das Hauptaugenmerk bildet.
Ein gute Methode um mit Zuständen zu arbeiten, bietet das Konzept der endlichen Automaten.
Hierbei wird ein Startzustand festgelegt, sowie eine endliche Anzahl von Zuständen, die im System mit
Zustandsübergängen erreicht werden können. Zu beachten ist, dass sich das System immer nur in genau
einem Zuständ befinden kann und dieser den SSOT (single source of truth) darstellt.
Die wohl wichtigste Eigenschaft eines endlichen Automaten ist jedoch, das bei gleicher Eingabe
immer die selbe Ausgabe erfolgt.
Kurz um: Der Automat befähigt einen, alle Zustände in dem sich ein System befinden kann
konsistent zu beschreiben. 
Unter der Vielzahl an endlichen Automaten fällt die Wahl auf den sogenannten Mealy-Automat.
Bei diesem wird der nächste Zustand auf Basis des derzeitigen Zustands und der erfolgten Eingabe ermittelt.
Die Eingabe spiegelt dabei ein Ereigniss wieder, welches durch den Nutzer selbst (und seinen Interaktionen) 
oder durch Komponenten der Peripherie ausgelöst wurde. Zu nennen wäre bswp. 
der Klick auf einen Knopf oder die Mitteilung des Betriebssystem, das der Standort sich verändert hat.
Die Beschreibung eines solchen endlichen Automaten lässt sich - unteranderem - mit
mathematischen Funktionen umsetzen. Für dies und der o.g. Prämisse, bei der die Ausgabe (hier: der Zustand) bei wiederholter,
gleicher Eingabe nicht abweichen darf, eignet sich ein Konzept welches auf Namen "Pure Functions" hört.
Dieses entspringt dem Programmierparadigma der funktionalen Programmierung und aus eben jener sollen mehrere Konzepte übernommen werden:
Unveränderliche Daten Strukturen. \\
Keine Seiteneffekte. \\
Kein globalen Variablen. \\
Pattern Matching + Expressions. \\
Unidirektional.\\
Um der hohen interaktivität einer Applikation Herr zu werden, wird eine weiteres Programmierparadigma und
Abstraktion herangezogen: Reaktive Programmierung.
Sie baut auf der funktionalen Programmierung auf und berücksichtig die oben genannten Eigenschaften.
Des weiteren erleichtert sie das arbeiten und koordinieren von "Threads". 
\\
Um den Umgang mit einem endlichen Automaten zu vereinfachen und den Quellcode in seiner lesbarkeit zu stärken,
wird die Entwicklung einer DSL (Domain Specific Language) in Erwägung gezogen.


