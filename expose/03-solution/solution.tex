\subsection{Solution}
\label{subsec:solution}

In order to reduce the cognitive burden on the developer when implementing the various components of MVI, the aim 
is to create a small, but opinionated framework.
\\
\\
At the beginning, the developer is encouraged to define the model. It is suppose to describes the state of the application and is therefore expected to contain
attributes
\dots 
\\
The framework aims to checks whether the model and its variables are immutable to make sure the developer adheres to the principle of immutability,
which MVI demands. This ensures that the developer does not forget it.
\\
\\
The next step will be to uniquely identify and describe the events that are caused by a user interaction.
As an example, a long-press on an item within a list can be interpreted as the intention of deletion. 
For this the framework should provide a structure that the developer uses to mark this kind of events.
The events then should be passed as an argument into a predefined "intent" function, which only takes marked events as a valid input.
Thus the developer will be forced to name every event that can possibly happen and to structure that part of code.
The "intent" function itself can serve as an entrypoint to the unidirectional flow of the framework (and thus MVI). It will be realised 
through the reactive programming style of the framework api.
\\
\\
Based on the type of event the developer might want to execute parts of his business logic. This can lead to mentioned "side effects" and
should be taken care of by the framework.


\\
In the next step, this intention is executed in 
the "model" function. \hl{It receives the current event and model as parameter. An associated function is added to each intention or event} (
\textcolor{red}{I didn't get that. Is that part of your solution? If so, which problem does it solve?}).
The library provides a structure that visibly identifies this type of method for the developer.
\\
This automatically leads to compartmentalization of the logic and increases its readability. Among other things it can happen that the developer has to access the business 
logic
\cite{} 
and thus side effects 
\cite{}
occur. Since it's enforced on the developer on most mobile platforms to defer heavy operations onto background threads, this must be taken
into account. The library can remedy this by using a reactive programming concepts.
\\
In addition, the model is made available to the developer at this point. This is an immutable data structure (object) that describes the state of the application. 
In the case of a login screen, for example, the e-mail entered by the user is stored here. The immutability makes it impossible to unintentionally change the object from elsewhere. 
In addition, the object can be accessed by several "threads" at the same time and thus does not stand in the way of asynchronous programming. The "model" function 
\hl{expects} (
    \textcolor{red}{Expects? I don't understand anything right now. How about "generates / creates" or something? The model is transferring the old model into a new one, isn't it?}
) a new state 
(or: a new model) as return value. Due to the immutability, the previous state remains untouched. Instead, it is copied and provided with new values at the same time. Furthermore, 
this prevents the developer from creating the state object as a global structure. It serves as a "single source of truth".
\\
The principle is similar to that of a finite (Mealy) automaton and is therefore conceived as a possible implementation for the "model" function within the library. 
For the logic described above, a class similar to that of a ViewModel or Presenter is provided to the developer. This separates the user interface (view) from this logic.
Finally, the view gets a single function in which the changed state is rendered.
\\
The development of a 
\hl{DSL (Domain Specific Language)} (
    \textcolor{red}{Still very fuzzy, as to what such a DSL could look like and what it brings to the developer.}
) is being considered in order to simplify the handling of the library and to strengthen the readability 
of the source \hl{code} (
    \textcolor{red}{All in all, it remains unclear to me what the result will be. In the first sentence, you write something about a library, followed by a few more details that don't really sharpen the "big picture". What does a developer gain from your library, to what extent does it make his life easier?}
).


% [x] single source of truth 
% [x] asynchronous code -> reactive takes care of that
% observer pattern -> reactive
% try to push the developer into a functional direction
% lowering the bar Of entry to write maintainable/readable code?