\subsection{Solution}
\label{subsec:solution}

% - to take a deeper look at MVI
% - where it comes from (flux + redux + mvc)
% - at existing solution
% - what they might do badly
% - solution or goal is to develop a framework

In order to overcome the mentioned problem, the aim will be to take a deeper look at what is important to understand and successfully implement Model-View-Intent.
For this it is essential to get a better overview over architectural patterns in general. Before this can be done meaningfully the first step must be 
to analyze why they came to life in the first place and what the exact motivation was. Further the problem they try to solve shall be layed out in more detail to 
get the bigger picture. In order to do justice to that, it is a necessity to review the history of architectural patterns and to work out how they have evolved over time.
By doing that it will also be possible to track down the issues that each of this architectural patterns brings with it.
\\
\\
Since Model-View-Intent takes a lot of its inspiration regarding its structure from Model-View-Cotroller, it is imperative to talk about it in more detail.
An attempt is made to identify the similarities and differences, and illustrate them to get a better grasp as to why Mode-View-Cotroller served as a source of inspiration.
\\
\\
After this is accomplished, the next step is to study the origins of Model-View-Intent. The beginning is made by the JavaScript library React and the application architecture
Flux, which introduced the concept of the unidirectional flow for building user interfaces. It is necessary to clarify which idea is hidden behind it and what it does
better than previous solutions. The important components of this framework shall be examined and shortly explained. Following on from this, a further improvement of Flux will 
be discussed: Redux. Differences to the idea and terminology of Flux will be pointed out and evaluated.
\\
\\
It then will be set out how Model-View-Intent functions in detail, what mechanism it employs/utilizes and which components it is made up of. In addition, it is examined which 
ideas it has adopted from the topics discussed before, whey they were chosen and how they interoperate with each other.
\\
\\
Thereafter, two other major building blocks of Model-View-Intent will be investigated. The first one being "functional" programming and the second one "reactive" programming.
Since both are classified as more complex paradigms, they will be briefly explained and it will be outlined to what role they play in Model-View-Intent.
\\
\\
The penultimate step is to explore already available solutions and gain valuable knowledge for the own realization of a framework. The challenge is to determine
how they implement Model-View-Intent and to comprehend what they do well, badly or not at all - also in the scope of the Android platform.
\\
\\
The next task and final objective is then to use the acquired knowledge to conceptualize and develop a framework that simplifies the implementation of Model-View-Intent in Android. 
Its purpose is to reduce the cognitive burden for a developer who is interested in deploying this very same pattern in their application. Hence it is also important to address the 
peculiarities of the Android platform when it comes to creating the concept. This in turn makes it mandatory to check and assess to what extent Model-View-Intent can be implemented 
in the context of Android and what difficulties it migh entail.
\\
\\
At last an example application shall be developed to showcase and verify the intended behaviour of the framework.