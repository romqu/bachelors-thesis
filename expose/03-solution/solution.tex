\subsection{Solution}
\label{subsec:solution}


In order to reduce the cognitive burden on the developer when implementing the various components of MVI, the aim 
is to create a small, but opinionated library.
Hierfür müssen im ersten Schritt die Ereignisse die von einer Aktion des Nutzer ausgehen eindeutig identifiziert und beschrieben werden.
Über eine "intent"-Funktion die bereitgestellt wird, wird das Ereignisse in etwas übersetzt, dass die Intention im Kontext der Applikation
deutlich macht. Um die Unterscheidung der Ereignisse übersichtlich zu gestalten, wird das Verfahren des "Pattern Matching" herangezogen.
So kann ein langer Klick auf ein Item innerhalb einer Liste bswp. als die Intention der Löschung interpertiert werden.
Im nächsten Schritt erfolgt die Ausführung dieser Intention in der "model"-Funktion. Sie erhält das derzeitige Ereigniss und Model als Parameter.
Zu jeder Intention/jedem Event gesellt sich eine zugehörige Funktion. Auch hierfür gibt die Bibliothek eine Struktur her, durch die diese Art von Mehtoden 
sichtbar gekennzeichnet werden. Dies führt automatisch zu einer Aufteilung der Logik und erhöht deren lesbarkeit. \\
Dabei kann es unteranderem vorkommen, dass der Entwickler auf die Geschäftslogik zugreifen muss und somit Seiteneffekte entstehen. Dazu wird seitens der 
Bibliothek mittels reaktiver Programmierung Abhilfe geschaffen. Zusätzlich wird an diesem Punkt dem Entwickler das Model zur Verfügung gestellt.
Es handelt sich dabei um eine unveränderliche Datenstruktur (Objekt), die den Zustand der Applikation beschreibt. Im Falle eines Anmelden Bildschirm wird z.B. 
hier die vom Nutzer eingetragene Email hinterlegt. Die Unveränderlichkeit macht es unmöglich, das Objekt an andere Stelle ungewollt zu verändern. 
Darüberhinaus kann auf das Objekt von mehreren "Threads" gleichzeitig zugergriffen werden und steht somit einer asynchronen Programmierung nicht im Wege.
Die "model"-Funktion erwartet einen neuen Zustand (oder: ein neues Model) als Rückgabe Wert. Aufgrund der Unveränderlichkeit bleibt der vorherige Zustand
unangetastet. Stattdessen wird er kopiert und zeitgleich mit neuen Werten versehen. Des weiteren wird der Entwicker dadurch davon abgehalten, das Zustands Objekt 
als globale Struktur anzulegen. Das Prinzip ähnelt das eines endlichen (Mealy) Automaten und ist deshalb als mögliche Implementation für die "model"-Funktion 
innerhalb der Bibliothek angedacht.
Für die oben beschriebene Logik wird dem Entwickler ein Klasse, ähnlich dem eines ViewModel oder Presenter an die Hand gegeben. Diese trennt die Benutzerobefläche (View)
von ebendieser Logik.
Zuletzt erhalt die View eine einzige Funktion, in der der veränderte Zustand gerendert wird.
\\
Um den Umgang mit der Bibliothek zu vereinfachen und den Quellcode in seiner lesbarkeit zu stärken,
wird die Entwicklung einer DSL (Domain Specific Language) in Erwägung gezogen.


