\subsection{Solution}
\label{subsec:solution}

% - to take a deeper look at MVI
% - where it comes from (flux + redux + mvc)
% - at existing solution
% - what they might do badly
% - solution or goal is to develop a framework


\newpage
In order to overcome the mentioned problem, the aim will be to take a deeper look at what is important to understand and successfully implement MVI.
For this it is essential to get a better overview over archhitectural patterns in general. Before this can be done meaningfully the first step must be 
to analyze why they came to life in the first place and what the exact motivation was. Further the problem they try to solve should be layed out in more detail to 
get the bigger picture. In order to do justice to that, it is a necessity to review the history of architectural patterns and to work out how they have evolved over time.
By doing that it will also be possible to track down the issues that each of this architectural patterns brings with it.
\\
\\
After this is accomplished, the next step is to study the origins of Model-View-Intent. The beginning is made by the framework Flux, which introduced the unidirectional flow. 
It is necessary to clarify which idea is hidden behind it and what it does better than previous solutions. All components of this framework should be examined and shortly explained.
\\ 
Following on from this, a further improvement of Flux will be discussed: Redux. Differences to the idea terminology of Flux will be pointed out.
\newpage





































In order to reduce the cognitive burden on the developer when implementing the various components of MVI, the aim 
is to create a small, but opinionated framework. (The goal is to provide the developer with structures, functions and components \dots) 
\\
\\
At the beginning, the developer is encouraged to define the model. It is suppose to describe the state of the application and is therefore expected to contain
variables which characterize this very state.\\
The framework aims to check whether the model and its variables are immutable to make sure the developer adheres to the principle of immutability,
which MVI (and its functional core) demands. This ensures that the developer does not forget it. Due to the immutability the developer must assure that every variable
has an initial value. At the end of this process an initial state is created.
\\
\\
The next step will be to uniquely identify and describe the events that are caused by a user interaction.
As an example, a long-press on an item within a list can be interpreted as the intention of deletion. 
For this the framework should provide a structure that the developer uses to mark and visibly identify this kind of events.
The events then should be passed as an argument into a predefined "intent" function, which only takes marked events as a valid input.
Thus the developer will be forced to name every event that can possibly happen and to structure the part of the code.
The "intent" function itself can serve as an entrypoint to the unidirectional flow of the framework (and thus MVI). It will be realised 
through the reactive programming style that the framework api strives to implement.
\\
\\
Based on the type of event the developer might want to execute parts of his business logic. This can lead to mentioned "side effects" and
should be supported by the framework to keep up the unidirectional data flow. The developer only has to tell the framework what logic he intends to call and 
the task of the framework is then to execute the logic safely and return the result (if any) without the developer having to intervene.
\\
\\
At this point the developer gets access to the model/state structure he has created beforehand/previously. It's the only point in the cycle (or unidirectional flow) 
where the developer gets hold of his state. This and the immutable property of the state makes it impossible to unintentionally change the object from elsewhere. It leads 
to code that is more predictable and less prone to errors. In other words: The model/state structure functions as the "single source of truth".
\\
\\
The, by the framework provided, model function expects a (new) state as a return value. Due to the above listed properties, the developer can not change the state 
in place, instead it has to be copied and provided with new values during the copy process: The model is transferring the old model into a new one.
Since this operation always follows the same schema, the framework will offer a structure that encapsulate it and the developer has to use.
This gives a better "separation of concerns", since it makes it clear as to which part of code is responsible for which operation.
\\
\\
For the entire logic described here, the framwork will provide an object that allows access to the mentioned functionality. In addition, but no less important, 
it serves as a "ViewModel", "Controller" or "Presenter" in that it will be the place to put in the user interface logic.


\newpage
In the next step, this intention is executed in 
the "model" function. \hl{It receives the current event and model as parameter. An associated function is added to each intention or event} (
\textcolor{red}{I didn't get that. Is that part of your solution? If so, which problem does it solve?}).
The library provides a structure that visibly identifies this type of method for the developer.
\\
This automatically leads to compartmentalization of the logic and increases its readability. Among other things it can happen that the developer has to access the business 
logic
\cite{} 
and thus side effects 
\cite{}
occur. Since it's enforced on the developer on most mobile platforms to defer heavy operations onto background threads, this must be taken
into account. The library can remedy this by using a reactive programming concepts.
\\
In addition, the model is made available to the developer at this point. This is an immutable data structure (object) that describes the state of the application. 
In the case of a login screen, for example, the e-mail entered by the user is stored here. The immutability makes it impossible to unintentionally change the object from elsewhere. 
In addition, the object can be accessed by several "threads" at the same time and thus does not stand in the way of asynchronous programming. The "model" function 
\hl{expects} (
    \textcolor{red}{Expects? I don't understand anything right now. How about "generates / creates" or something? The model is transferring the old model into a new one, isn't it?}
) a new state 
(or: a new model) as return value. Due to the immutability, the previous state remains untouched. Instead, it is copied and provided with new values at the same time. Furthermore, 
this prevents the developer from creating the state object as a global structure. It serves as a "single source of truth".
\\
The principle is similar to that of a finite (Mealy) automaton and is therefore conceived as a possible implementation for the "model" function within the library. 
For the logic described above, a class similar to that of a ViewModel or Presenter is provided to the developer. This separates the user interface (view) from this logic.
Finally, the view gets a single function in which the changed state is rendered.
\\
The development of a 
\hl{DSL (Domain Specific Language)} (
    \textcolor{red}{Still very fuzzy, as to what such a DSL could look like and what it brings to the developer.}
) is being considered in order to simplify the handling of the library and to strengthen the readability 
of the source \hl{code} (
    \textcolor{red}{All in all, it remains unclear to me what the result will be. In the first sentence, you write something about a library, followed by a few more details that don't really sharpen the "big picture". What does a developer gain from your library, to what extent does it make his life easier?}
). 