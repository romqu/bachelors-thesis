\subsection{Solution}
\label{subsec:solution}

In order to reduce the cognitive burden on the developer when implementing the various components of MVI, the aim 
is to create a small, but opinionated library.
\\
The first step will be to uniquely identify and describe the events that are caused by a user interaction.
Via a provided intent function, the events are translated into something that makes the intention clear in the context of the application.
In order to make the distinction between the events clear the procedure of "Pattern Matching" 
\cite{wikiPatterMatching,scalaDocsPatterMatching}
will be utilized. A long-press on an item within a list for example, can be interpreted as the intention of deletion. In the next step, this intention is executed in 
the "model" function. It receives the current event and model as parameter. An associated function is added to each intention or event. The library provides a structure 
that visibly identifies this type of method for the developer.
\\
This automatically leads to compartmentalization of the logic and increases its readability. Among other things it can happen that the developer has to access the business 
logic
\cite{wikic2BusinessLogic} 
and thus side effects occur. Since it's enforced on the developer on most mobile platforms to defer heavy operations onto background threads, this must be taken
into account. The library can remedy this by using a reactive programming concepts.
\\
In addition, the model is made available to the developer
at this point. This is an immutable data structure (object) that describes the state of the application. In the case of a login screen, for example, the e-mail 
entered by the user is stored here. The immutability makes it impossible to unintentionally change the object from elsewhere. In addition, the object can be accessed 
by several "threads" at the same time and thus does not stand in the way of asynchronous programming. The "model" function expects a new state (or: a new model) 
as return value. Due to the immutability, the previous state remains untouched. Instead, it is copied and provided with new values at the same time. Furthermore, 
this prevents the developer from creating the state object as a global structure. It serves as a "single source of truth".
\\
The principle is similar to that of a finite (Mealy) automaton and is therefore conceived as a possible implementation for the "model" function within the library. 
For the logic described above, a class similar to that of a ViewModel or Presenter is provided to the developer. This separates the user interface (view) from this logic.
Finally, the view gets a single function in which the changed state is rendered.
\\
The development of a DSL (Domain Specific Language) is being considered in order to simplify the handling of the library and to strengthen the readability 
of the source code.


% [x] single source of truth 
% [x] asynchronous code -> reactive takes care of that
% observer pattern -> reactive
% try to push the developer into a functional direction
% lowering the bar Of entry to write maintainable/readable code?