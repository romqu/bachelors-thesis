\subsection{Solution}
\label{subsec:solution}

In order to reduce the cognitive burden on the developer when implementing the various components of MVI, the aim 
is to create a small, but opinionated framework. (The goal is to provide the developer with structures, functions and components \dots) 
\\
\\
At the beginning, the developer is encouraged to define the model. It is suppose to describe the state of the application and is therefore expected to contain
variables which characterize this very state.\\
The framework aims to check whether the model and its variables are immutable to make sure the developer adheres to the principle of immutability,
which MVI (and its functional core) demands. This ensures that the developer does not forget it. Due to the immutability the developer must assure that every variable
has an initial value. At the end of this process an initial state is created.
\\
\\
The next step will be to uniquely identify and describe the events that are caused by a user interaction.
As an example, a long-press on an item within a list can be interpreted as the intention of deletion. 
For this the framework should provide a structure that the developer uses to mark and visibly identify this kind of events.
The events then should be passed as an argument into a predefined "intent" function, which only takes marked events as a valid input.
Thus the developer will be forced to name every event that can possibly happen and to structure the part of the code.
The "intent" function itself can serve as an entrypoint to the unidirectional flow of the framework (and thus MVI). It will be realised 
through the reactive programming style that the framework api strives to implement.
\\
\\
Based on the type of event the developer might want to execute parts of his business logic. This can lead to mentioned "side effects" and
should be supported by the framework to keep up the unidirectional data flow. The developer only has to tell the framework what logic he intends to call and 
the task of the framework is then to execute the logic safely and return the result (if any) without the developer having to intervene.
\\
\\
At this point the developer gets access to the model/state structure he has created before. It's the only point in the cycle (or unidirectional flow) where the 
developer gets hold of his state. This and the immutable property of the state makes it impossible to unintentionally change the object from elsewhere. It leads 
to code that is more predictable and less prone to errors. In other words: The model/state structure functions as the "single source of truth".
\\
\\
The, by the framework provided, model function expects a (new) state as a return value. Due to the above listed properties, the developer can not change the state 
in place, instead it has to be copied and provided with new values during the copy operation: The model is transferring the old model into a new one.

\newpage
In the next step, this intention is executed in 
the "model" function. \hl{It receives the current event and model as parameter. An associated function is added to each intention or event} (
\textcolor{red}{I didn't get that. Is that part of your solution? If so, which problem does it solve?}).
The library provides a structure that visibly identifies this type of method for the developer.
\\
This automatically leads to compartmentalization of the logic and increases its readability. Among other things it can happen that the developer has to access the business 
logic
\cite{} 
and thus side effects 
\cite{}
occur. Since it's enforced on the developer on most mobile platforms to defer heavy operations onto background threads, this must be taken
into account. The library can remedy this by using a reactive programming concepts.
\\
In addition, the model is made available to the developer at this point. This is an immutable data structure (object) that describes the state of the application. 
In the case of a login screen, for example, the e-mail entered by the user is stored here. The immutability makes it impossible to unintentionally change the object from elsewhere. 
In addition, the object can be accessed by several "threads" at the same time and thus does not stand in the way of asynchronous programming. The "model" function 
\hl{expects} (
    \textcolor{red}{Expects? I don't understand anything right now. How about "generates / creates" or something? The model is transferring the old model into a new one, isn't it?}
) a new state 
(or: a new model) as return value. Due to the immutability, the previous state remains untouched. Instead, it is copied and provided with new values at the same time. Furthermore, 
this prevents the developer from creating the state object as a global structure. It serves as a "single source of truth".
\\
The principle is similar to that of a finite (Mealy) automaton and is therefore conceived as a possible implementation for the "model" function within the library. 
For the logic described above, a class similar to that of a ViewModel or Presenter is provided to the developer. This separates the user interface (view) from this logic.
Finally, the view gets a single function in which the changed state is rendered.
\\
The development of a 
\hl{DSL (Domain Specific Language)} (
    \textcolor{red}{Still very fuzzy, as to what such a DSL could look like and what it brings to the developer.}
) is being considered in order to simplify the handling of the library and to strengthen the readability 
of the source \hl{code} (
    \textcolor{red}{All in all, it remains unclear to me what the result will be. In the first sentence, you write something about a library, followed by a few more details that don't really sharpen the "big picture". What does a developer gain from your library, to what extent does it make his life easier?}
).


% [x] single source of truth 
% [x] asynchronous code -> reactive takes care of that
% observer pattern -> reactive
% try to push the developer into a functional direction
% lowering the bar Of entry to write maintainable/readable code?