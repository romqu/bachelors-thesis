\subsection{Problem}
\label{subsec:problem}

Today's applications seem to be increasing in complexity over the last few years. 
Especially in the field of frontend development, the range of functions has increased \cite{kevin2018}.
The web development has transitioned from server rendered, page-reloading websites, to modern so called single page applications or SPA's.
But the same applies to the mobile world: Social networks, navigation, sharing and editing files together is a common desire by the user.
Ein großer Teil der Applikationen steht somit auch im Austausch mit APIs, greift auf lokale und externe Datenbanken zu oder interagiert 
mit dem zugrundeliegenden System selbst (bswp. die periodische Erfassung des Standortes via GPS oder WiFi).
Zusätzlich zu der Interaktion mit dem Nutzer und dessen Einfluss, muss die Anwendungen auf oben genannte Einflüsse reagieren können 
und vorrausgegangene Ereignisse und deren Auswirkung speichern. Es muss bekannt sein, welche Zustände bei welchen Ereignissen eintreten
können und welche nicht. Dies ist nötig, um eine zuverlässige Funktionsweise einer Appliaktionen zu garantieren.
Folgendes Beispiel soll den Sachverhalt verdeutlichen:
Der Nutzer befindet sich auf einem "Anmelden" Fenster. In diesem kann der Nutzer eine E-Mail-Adresse und ein Passwort eingeben.
Darunter befindet sich ein herkömmlicher "Anmelden" Knopf. Des weiteren existiert die Möglichkeit auf "Passwort vergessen?" zu klicken.
Die folgenden Zustände können hierbei eintreten:

\begin{itemize}
    \item Die E-Mail-Adresse ist nicht zulässig und das Passwort Feld leer
    \begin{itemize}
        \item Der "Anmelden" Knopf ist deaktiviert
     \end{itemize}
    \item Die E-Mail-Adresse ist zulässig und das Passwort Feld leer
    \begin{itemize}
        \item Der "Anmelden" Knopf ist deaktiviert
    \end{itemize}
    \item Die E-Mail-Adresse ist zulässig und das Passwort Feld nicht leer
    \begin{itemize}
        \item Der "Anmelden" Knopf ist aktiviert
    \end{itemize}
    \item Der Nutzer betätigt den "Anmelden" Knopf
    \begin{itemize}
        \item Der "Anmelden" Knopf ist aktiviert
    \end{itemize}
    \item Die Email ist inkorrekt oder existiert nicht
    \item Die Email ist korrekt und das Passwort falsch
    \item Die Email ist korrekt und das Passwort richtig
    \begin{itemize}
        \item Der Nutzer gelangt zum nächsten Fenster
    \end{itemize}
    \item Eine dreimalige falsche Eingabe des Passworts führt zu einer temporären Sperrung
    \item Der Nutzer klickt auf "Passwort vergessen"
    \item Es gibt einen Netzwerkfehler
    \begin{itemize}
        \item Es wird eine Fehlermeldung angezeigt
    \end{itemize}
    \item Es besteht keine Verbindung zum Internet
    \begin{itemize}
        \item Es wird eine Meldung angezeigt
    \end{itemize}
    \item Der Nutzer dreht das Smartphone
    \begin{itemize}
        \item Der Zustand muss gespeichert werden
    \end{itemize}
    \item Die Appliaktionen wird vom System beendet
    \begin{itemize}
        \item Der Zustand muss gespeichert werden
    \end{itemize}
\end{itemize}

Anhand dessen wird sichtbar, wie viele Ereignisse und Zustände bereits aus einer simplen Funktion wie "Annmelden" hervorgehen.
Die Schwiriegkeit die hierbei unter anderem entsteht, ist, die Fülle an möglichen Zuständen zu konkretisieren und 
formal als auch inhaltlich "ansprechend" darzustellen/zu beschreiben.
Wie sollte die Struktur eines Programmes aufgebaut/organisiert werden, wenn man Zustandsorientiert arbeitet?
Wirft der Entwickler einen Blick auf die Implementierung  einer Funktion (wie das obige Beispiel des Vorgangs des Anmeldens), 
ist oft nicht gleich ersichtlich, welche Zustände insgemein existieren.
Überhaupt ist es oft kompliziert, den Ablauf eines Programmes ohne größen Aufwand nachzuvollziehen.
Dazu gesellt sich zwangsläufig die Frage, auf welche Art und Weise ein Zustand ünberhaupt definiert wird. 
Wird er dynamisch, anhand eines hinterlegten Regelwerks gebildet, oder ist er von Beginn an festgelegt?
% --> mutable state -> bad
% --> Zustände verstreut
Nicht weniger unherheblich ist, wie der Übergang von einem Zustand in einen anderen Zustand erfolgt und was 
genau der Initiator eines Übergang ist.
Ein weitere, nicht zu unterschätzende Problematik ist die asynchrone Programmierung bzw. "Multi Threading",
welches in heutigen Appliaktionen immer öfters Anwendung findet. Soll in einer Android Appliktionen bspw. auf das Internet
zugegriffen werden, ist der Einsatz eines zusätzlichen "Thread" pflicht.
Dies führt unter Umständen zu sogenannten "Side effects" und trägt dazu bei, das der Quellcode unleserlich wird.(Callback Hell)

% Die oben aufgezeigte Problematik ist ein Faktor, der dazu führen kann, dass die Implementierung einer Funktion (hier: Anmelden),
% nicht alle möglichen Zustände/Fälle abdeckt. Dies wiederum lässt etwas zu, das einem nichtdeterministisches Verhalten gleichkommt.
% Ein Ereignis, das nicht bedient wird, könnte unerwartete Komplikationen hervorrufen.

% Zustandsorientiert programmieren
% formale Beschreibung

% wie formuliere ich Zustände ?
% wie organisiere Zustandsorientiert ?

% deklaritive Beschreibung / pattern matcher ?
% 
% session 

% kotlin dsl

% Z1 = alter > 0, email != ""

% kernprobleme/abgrenzen

% mvi

% seqentiell 