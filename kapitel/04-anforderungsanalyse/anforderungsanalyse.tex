\section{Anforderungsanalyse}
\label{sec:anforderungsanalyse}
In diesem Kapitel werden beide Seiten von Anforderungen beschrieben: Funktional und Nichtfunktional. 

\subsection{Funktionale Anforderungen}
Die Funktionalen Anforderungen dienen dafür, um die genaue Funktionalität und das Verhalten eines Systems zu beschreiben. Es wird behandelt, was das System können soll und muss. Um dies besser abbilden zu können, werden die einzelnen Anforderungen einer Gewichtung unterzogen. Diese Gewichtung lässt sich in Form von »Muss«,»Soll« und »Kann« Anforderungen ausdrücken. Aufgrund des kleines Rahmens und Zeitfensters dieser Bachelorarbeit wird sich im diesen Teil ausschließlich auf »Muss«-Anforderungen beschränkt, d.h. jene Funktionalität, welches das Framework erfüllen muss. Für die Übersichtlichkeit werden sämtliche Anforderungen nummeriert und mit dem Kürzel »FA« versehen.
\\
\\
\textbf{[A01] Identifizieren von »Intents«}
\\
Dem Nutzer des Frameworks muss es möglich sein, die »Intents« seiner Anwendung eindeutig zu markieren.
\\
\\
\textbf{[A02] Trennung von Bussines und Ansicht Logik}
\\
Ähnlich wie in MVP oder MVC muss das Framework eine strikte Separierung von (Bussines) Logik und der Ansicht Logik fördern. 
\\
\\
\textbf{[A03] Überprüfung des Models als unveränderliche Datenstruktur}
\\
Es ist zwingende erforderlich, dass die vom Nutzer gewählte Struktur für das Model nicht direkt verändert werden kann. Hierfür muss das Framework verifizieren, dass es sich um  eine  unveränderliche Datenstruktur
handelt.
\\
\\
\textbf{[A04] Bereitstellung eines »Reducers«}
\\
Für das erzeugen von einem neuem Model muss dem Entwickler eine Funktionen in Form eines Reducers bereitgestellt werden. Diese muss das derzeitige Model und Ereignis zur Verfügung stellen. 
\\
\\
\textbf{[A05] Handhabung von Seiteneffekten}
\\
Auf Grund der Tatsache, dass in den meisten Anwendungen Seiteneffekte auftreten, muss dieses vom Framework abgedeckt sein.
\\
\\
\textbf{[A06] Verwalten des Zustands}
\\
Ein zentraler Bestandteil des Framework ist es, das Model bzw. den Zustand der Anwendung zu Verwalten. 
\\
\\
\textbf{[A07] Funktion für die Aktualisierung der Ansicht}
\\
Nachdem ein neues Model erzeugt wurde, muss dieses an die Ansicht weitergegeben werden, welches sich daraufhin aktualisiert. Hierfür muss das Framework eine dementsprechende Funktion bereitstellen.
\\
\\
\textbf{[A08] Speichern des Zustands}
\\
Der Zustand muss im transienten und persistenten Speicher abgelegt werden.
\\
\\
\textbf{[A09] Wiederherstellung des Zustands}
\\
Sollte es zu einem Verlust der Models kommen, muss dieses ordnungsgemäß und wiederhergestellt werden.
Dies sollte ohne Eingriff des Entwicklers von statten gehen.
\\
\\
\textbf{[A10] Asynchrone Ausführung}
\\
Viele der Zugriffe auf eine Datenbank oder einer Rest-Api finden auf unterschiedlichen Threads statt.
Hierbei darf es zu keinen unerwarteten Problemen (z.B. Race.Conditions) kommen.
\\
\\
\subsection{Nicht funktionale Anforderungen}
Die nicht funktionale Anforderungen sind im Gegensatz zu den funktionalen unspezifisch für ein Produkt, d.h. sie haben meist nur einen indirekten Einfluss auf das System. So kann beispielsweise festgelegt werden, dass die Ausführung einen bestimmten Funktionalität nur ein gewisses Maß an Zeit in Anspruch nehmen darf. Dazu gehören auch Qualitätsmerkmale, die erfüllt werden müssen.Für die Übersichtlichkeit werden sämtliche Anforderungen nummeriert und mit dem Kürzel »NFA« versehen.
\\
\\
\textbf{[A11] Dogmatisches Framework}
\\
Das Framework soll den Entwickler »and die Hand nehmen« und genaue Vorgaben für die Anwendung kommunizieren. Damit sind zielgenauere Funktionen möglich und die Komplexität kann unter Umständen niedriger gehalten werden. Dies birgt allerdings die Gefahr, dass bei eigenwilliger Anwendung - und der damit einhergehenden Abweichung der Instruktionen - des Entwicklers es zu Komplikationen kommen kann.
\\
\\
\textbf{[A12] Unidirektional}
\\
Der in MVI geforderte unidirektionale Datenfluss muss eingehalten werden.
\\
\\
\textbf{[A13] Kotlin spezifische Implementierung}
\\
Für die Umsetzung wird Kotlin als Programmiersprache herangezogen. Sie bietet einige syntaktische Vorteile gegenüber Java.
\\
\\
\textbf{[A14] Reaktiv \& Funktional}
\\
Das Framework soll auf verstärkt reaktiven und funktionalen Konzepten aufbauen.
\subsection{Ubersicht der Anforderungen}
Für eine bessere Übersicht der funktionalen (fa) und nicht funktionalen (nfa) Anforderungen werden diese im Folgenden in einer Tabelle zusammengefasst.
\\
\\
%\setlength{\tabcolsep}{0.5em} % for the horizontal padding
% {\renewcommand{\arraystretch}{1.5}% for the vertical padding
\begingroup
\setlength{\tabcolsep}{10pt} % Default value: 6pt
\renewcommand{\arraystretch}{1.5} % Default value: 1
\begin{tabular}{ | l | l | c | }
	\hline
	ID & Anforderung & Typ
	\\
	\hline
	01 & Identifizieren von »Intent«, »Action«, »State« und »Result« & fa
	\\
	\hline	
	02 & Trennung von Business und Ansicht Logik & fa
	\\
	\hline
	03 & Überprüfung des Zustands als unveränderliche Datenstruktur & fa
	\\
	\hline
	04 & Bereitstellung eines »Reducers« & fa
	\\
	\hline
	05 & Handhabung von Seiteneffekten & fa 
	\\
	\hline
	06 & Verwalten des Zustands & fa 
	\\
	\hline
	07 & Funktion für die Aktualisierung der Ansicht & fa
	\\
	\hline
	08 & Speichern des Zustands & fa
	\\
	\hline
	09 & Wiederherstellung des Zustands & fa
	\\
	\hline
	10 & Asynchrone Ausführung & fa
	\\
	\hline
	11 & Dogmatisches Framework & na
	\\
	\hline
	12 & Unidirektionaler Datenfluss & nfa
	\\
	\hline
	13 & Kotlin spezifische Implementierung & nfa
	\\
	\hline
	14 & Reaktiv \& Funktional & nfa
	\\
	\hline
\end{tabular}
\endgroup

\subsection{Begutachtung bestehender MVI-Frameworks/Bibliotheken}
In diesem Kapitel wird ein Blick auf bereits bestehende MVI-Frameworks/Bibliotheken geworfen.

\subsubsection{MVICore}
\label{subsubsec:mvicore}
Hierbei handelt es sich um ein auf MVI ausgerichtet Framework dessen Entwicklung seit 2018 auf Github stattfindet.
\cite{mviCoreGithub}
Es bietet eine vollständige Abdeckung der von MVI verlangten Komponenten und stellt darüber hinaus weitere Eigenschaften wie »Time Travel Debuggig« und »Middlewares« zur Verfügung.
\\\\
Ähnlich wie im Konzept existiert hier eine Klasse, die den Zustand verwaltet: der 'Store'. Es besteht hierfür aber keine Überprüfung auf Unveränderlichkeit. 
\\\\
Eine erweitere Form des 'Store' ist das 'Feature' Interface. Es sind verschiedene »Feature« Implementationen für unterschiedliche Anforderungen vorhanden. Zu gibt es bspw. das »ActorReducerFeature« welches für asynchrone Logik gedacht ist und das arbeiten mit dem Typ »Observable« erlaubt. Darüber erfolgt die Realisierung des Unidirektionalen Datenflusses.
\\\\
Ein erstes großes Plus ist das Vorhandensein der automatischen Beendigung von Abonnements die im Zuge der Nutzung von 'Observable' entstehen. Die bedeutet, der Entwickler muss keine Sorge bezüglich eines Speicherlecks haben. Möglich ist dies durch die Bindung des 'Features' an den Lebenszyklus der »View« Komponente. Hierfür existiert eine »Binder« Klasse.
\\\\
Ein weiter und wichtiger Pluspunkt ist die automatische Speicher- und Wiederherstellung des Zustands. Damit ist garantiert, dass nach Drehung des Geräts sich der Nutzer in dem selben Zustand wie zuvor befindet.
\\\\
Des weiteren wird durch »Middleware« eine Möglichkeit geboten, »Cross-Cutting Concerns« wie z.B. das Loggen als generische Plugins zu implementieren und einem oder mehreren 'Feature' Klassen zuzuweisen.
\\\\
Insgesamt übersteigt dieses Framework den Funktionsumfang des hier niedergeschrieben Konzepts und erfüllt soweit alle Anforderungen.